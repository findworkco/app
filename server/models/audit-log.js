// Load in our dependencies
var assert = require('assert');
var _ = require('underscore');
var Sequelize = require('sequelize');
var sequelize = require('./_sequelize');
var customTypes = require('./utils/custom-types');

// Define our constants
exports.ACTION_CREATE = 'create';
exports.ACTION_UPDATE = 'update';
exports.ACTION_DELETE = 'delete';
exports.VALID_ACTIONS = [exports.ACTION_CREATE, exports.ACTION_UPDATE, exports.ACTION_DELETE];

exports.SOURCE_CANDIDATES = 'candidates';
exports.SOURCE_QUEUE = 'queue';
exports.SOURCE_SERVER = 'server';
exports.VALID_SOURCES = [exports.SOURCE_CANDIDATES, exports.SOURCE_QUEUE, exports.SOURCE_SERVER];

// Define and export our model
// http://docs.sequelizejs.com/en/v3/docs/models-definition/
// DEV: We don't use `baseDefine` as this isn't a typical model
//   (e.g. no fancy getters, no audit hooks)
// DEV: Based on memory, verified by http://stackoverflow.com/a/2015276
module.exports = _.extend(sequelize.define('audit_log', {
  id: {
    type: customTypes.ID, defaultValue: Sequelize.UUIDV4, primaryKey: true,
    validate: {isUUID: 4}
  },
  // 'server', 'candidates', etc
  // DEV: Validation for `source_id` being set for non-server type is in options
  source_type: {
    type: Sequelize.STRING(255), allowNull: false,
    validate: {isIn: {args: [exports.VALID_SOURCES], msg: 'Source must be server or candidates'}}
  },
  source_id: {
    // DEV: Since this isn't a foreign key, we can use UUID check for sanity
    type: customTypes.ID, allowNull: true,
    validate: {isUUID: 4}
  },

  // 'candidates', 'applications', interviews', etc
  table_name: {type: Sequelize.STRING(255), allowNull: false},
  table_row_id: {type: customTypes.ID, allowNull: false},

  // 'create', 'update', 'delete'
  action: {
    type: Sequelize.STRING(32), allowNull: false,
    validate: {isIn: {args: [exports.VALID_ACTIONS], msg: 'Action must be create, update, or delete'}}
  },

  // 2016-01-01T00:00:00Z
  timestamp: {type: Sequelize.DATE, allowNull: false},

  // DEV: We could store `changed_values_previous` and `changed_values_current`
  //   but for simplicity of querying, we are storing all values
  // DEV: We wanted to use JSONB since writes only occur once whereas reads can occur many times
  //   However, PostgreSQL@9.3 lacks JSONB =(
  //   https://www.postgresql.org/docs/9.3/static/datatype-json.html
  // {id: abc, email: abc1, password: hash1, ...}
  previous_values: {type: Sequelize.JSON, allowNull: false},
  // {id: abc, email: abc2, password: hash2, ...}
  current_values: {type: Sequelize.JSON, allowNull: false},

  // DEV: We don't use `customTypes.ID` as transaction id's are generated by Sequelize
  transaction_id: {
    // DEV: Since this isn't a foreign key, we can use UUID check for sanity
    type: Sequelize.UUID, allowNull: true,
    validate: {isUUID: 'all'}
  }
}, {
  validate: {
    requireSourceId: function () {
      if ([exports.SOURCE_QUEUE, exports.SOURCE_SERVER].indexOf(this.getDataValue('source_type')) === -1) {
        assert(this.getDataValue('source_id'), 'source_id required for non-server/non-queue sources in audit log');
      }
    }
  },

  // Disable `created_at`/`updated_at` timestamps
  timestamps: false
}), exports);
